---
title: "Using readwritesqlite"
author: "Joe Thorley"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using readwritesqlite}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

`readwritesqlite` is an R package to enhance reading and writing to SQLite databases.

## Starting

The first task after loading `readwritesqlite` is to create an object of class SQLiteConnection.
Below we create one in memory although in general the user will want to specify a path.
```{r}
library(readwritesqlite)
conn <- DBI::dbConnect(RSQLite::SQLite(), ":memory:")
```

## Writing Data

Individual data frames, environments or named lists of data frames can be written to a connection using `rws_write_sqlite()`.

In the case of a data frame the default table name is the name of the object.
```{r}
rws_write_sqlite(rws_data, exists = FALSE, conn = conn)
rws_list_tables(conn)
```
The fact that `rws_write_sqlite()` accepts environments means that the user can easily
write all the data frames in the current environment to a SQLiteConnection.
```{r}
a_table <- rws_data[c("date", "logical")]
another_table <- rws_data[c("factor", "ordered")]
not_a_table <- 1
rws_write_sqlite(environment(), exists = FALSE, all = FALSE, conn = conn)
rws_list_tables(conn)
```
Objects which are not data frames are silently filtered from enviromnents but cause an error with lists.

### Exists

By default the `exists` argument to the `rws_write_sqlite()` function is `TRUE`.
This means that only existing tables (which were presumably created by the database designer with appropriate checks and foreign keys) can be written to.
If the user wishes to automatically create new tables if they don't exist before writing then they should set `exists = NA`.
If the user only wishes to create and write to new tables then they should set `exists = FALSE`.

### Foreign Keys

The `rws_write_sqlite()` function ensures that writing the new data frame(s) to the database does not violate foreign keys.
If any data does the database is left unchanged.

### Commiting Data

By default, if no check or key violations occur the data frame(s) are written to the database.
Otherwise an error message is issued and all changes are rolled back.
If the user wishes to simply confirm that data could be written to a database without actually making any changes then they
can call `rws_write_sqlite()` with `commit = FALSE`.

### Deleting Data (and Meta Data)

Meta data is recorded if the user uses `rws_write_sqlite()` to write data to an empty table.
In order to change the meta data the user should read the existing data from the table 
(using `rws_read_sqlite()`), modify it accordingly and then re-write it using 
`rws_write_sqlite()` with `delete = TRUE`. 
The only exception is for factors and ordered factors.
In this case the user can pass data with additional or rearranged levels without deleting the existing data.

### Duplicate Data

When passing data frames to `rws_write_sqlite()` in the form of an environment or named list, each table must be represented by just one data frame if `unique = TRUE` (the default), `delete = TRUE` (because then the order matters) or `exists = FALSE` (because the table will exist when the duplicate is written).

### All Data

When passing data frames to `rws_write_sqlite()` in the form of an environment or named list, if `all = TRUE` (the default) and `exists` is not `FALSE` then each existing tables must be represented at least once.
This option is useful for checking all the tables in a data frame are populated when transferring data from an old to new database.

## Reading Data

Data can be read using `rws_read_sqlite()` which either takes a vector of table names or the connection as the first argument.
`rws_read_sqlite()` returns a named list of data frames (or if the `tibble` package is installed tibbles).
If the connection is the first argument then the named list consists of all tables in the data base.
```{r}
tables <- rws_read_sqlite(conn)
names(tables)
tables$rws_data
```

If the user wishes to read a single data frame they can use `rws_read_sqlite_table()`
```{r}
rws_read_sqlite_table("rws_data", conn = conn)
```

The `rws_read_sqlite_meta()` and `rws_read_sqlite_log()` allow the user to read the meta and log tables.
```{r}
rws_read_sqlite_meta(conn)
```

```{r}
rws_read_sqlite_log(conn)
```

## Cleaning Up

It's good practice to close a connection once you have finished with it.
```{r}
DBI::dbDisconnect(conn)
```
